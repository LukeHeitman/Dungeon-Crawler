The majority of our code is in our template.py file. We have a separate ‘Assets’ folder that contains png files that we use to display sprites in the game as well as the our background images. This folder also contains an ‘mp3’ file to be used for music and a ‘wav’ song that we play when the player picks up a key. In the template file we declare some constants to be used regarding the height and width of the window. This way it is easier to put certain x and y coordinates in perspective throughout the code. We have constants to represent the game map, as the background border tiles are 16 pixels and the game tiles that the sprites can move and spawn on are 32 pixels. We also have constants to represent some colors and a constant to represent a default font that we will use in our game that is drawn on from our assets folder. 

All of our game functionality is in our ‘main’ function. We have a variable called FPSCLOCK that we are able to “tick” a specific number of frames per second depending on different scenarios. We load an mp3 file from our Assets folder and set this song to play forever by passing in the “-1” value in pygame. Our game begins with an intro screen in which we display the name “Dungeon Crawler” and display the objective and instructions on how to play the game. We initialize variables for level and lives as these will carry over each time the player advances a level or loses a life by colliding with a monster.	

We have a main game loop that initializes the pygame application and sets up the code for the main game function. Then the game loop function is called, which is where most of the action happens. It creates sprites by calling on their class constructors from a separate ‘sprites.py’ file. Depending on each level we are able to render a monster visible and add them to the screen to follow the user and make it more difficult to pick up keys. We use a method to spawn keys and the initial demon randomly on the screen in real time so that they are unpredictable but also do not spawn too close to the user. The other monsters have set spawn locations that we determined would be best for gameplay. 

Another large part of our file is our Sprites.py file, which contains all of our sprite classes. Each class has a variety of variables and functions assigned to it. We decided to make this decision in order to keep the many sprite variables together to keep the file cleaner. There are also a variety of functions, such as the different movement or draw functions, that are called constantly for these sprites. In another attempt to clean up our code, we placed all of  our loaded image files used for sprite animation, into a seperate dictionary file, which is then imported in.

We have two text fields in the upper left and upper right corners that update to show the player which level they are on and how many lives they have left. If the player loses the game by losing all of their lives they can restart the game by pressing the ‘R’ key. We displayed this on a separate screen that comes up once the game has been lost. Alternatively, the game can be exited out of without any issues by quitting the window of the game. We are able to update the display at any moment after specific events using ‘pygame.display.update()’ and we can influence the frames of the screen with our global FPSCLOCK variable. 
